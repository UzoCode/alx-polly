Of course. Using `upsert()` with composite unique keys in Supabase is a common requirement, especially for things like a `votes` table where a user should only be able to vote once per poll.

The key to making this work is the `.onConflict()` modifier, where you specify the columns that make up your unique constraint.

Hereâ€™s a complete guide with TypeScript examples.

### Step 1: Define the Table Schema

First, ensure your `votes` table is set up correctly in your database with a composite `UNIQUE` constraint on `poll_id` and `user_id`. You can also make this your primary key if it makes sense for your schema.

Here is the SQL for creating such a table:

```sql
CREATE TABLE public.votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ WITH TIME ZONE DEFAULT NOW() NOT NULL,
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  poll_id BIGINT REFERENCES public.polls(id) NOT NULL,
  option_id BIGINT NOT NULL,
  
  -- This is the crucial part for the upsert operation
  CONSTRAINT unique_vote_per_user_per_poll UNIQUE (poll_id, user_id)
);

-- Optional: Add policies for row-level security
ALTER TABLE public.votes ENABLE ROW LEVEL SECURITY;
-- Add policies as needed, for example:
CREATE POLICY "Allow authenticated users to insert their own vote"
  ON public.votes FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Allow user to update their own vote"
  ON public.votes FOR UPDATE
  USING (auth.uid() = user_id);
```

### Step 2: TypeScript Example for Upsert

Now, let's write the TypeScript code to perform the upsert operation. When you `upsert`, you need to tell Supabase which constraint to check for conflicts.

1.  **Define a Type (Good Practice)**

    It's helpful to define a type for your vote data.

    ```typescript
    // lib/types/index.ts
    export type Vote = {
      poll_id: number;
      user_id: string;
      option_id: number;
    };
    ```

2.  **The `upsert()` Call**

    In your action or server-side function, you can now use `upsert()` with `onConflict`.

    ```typescript
    import { createServerClient } from '@/lib/supabase/server'; // Or your client
    import { Vote } from '@/lib/types';
    import { cookies } from 'next/headers';

    /**
     * Casts or updates a vote on a poll.
     * If the user has already voted on this poll, their vote will be updated.
     * Otherwise, a new vote will be inserted.
     */
    export async function castVote(voteData: Vote) {
      const cookieStore = cookies();
      const supabase = createServerClient(cookieStore);

      const { data, error } = await supabase
        .from('votes')
        .upsert(
          {
            poll_id: voteData.poll_id,
            user_id: voteData.user_id,
            option_id: voteData.option_id, // The value to insert or update
          },
          {
            // Specify the columns that form the unique constraint.
            // Supabase will check for a row with a matching (poll_id, user_id) pair.
            onConflict: 'poll_id,user_id',
          }
        )
        .select()
        .single(); // .single() is useful to get the upserted row back

      if (error) {
        console.error('Error upserting vote:', error);
        throw new Error('Could not cast or update vote.');
      }

      console.log('Successfully cast/updated vote:', data);
      return data;
    }
    ```

### Explanation

-   `.upsert(data, options)`: The first argument is the data you want to insert or update.
-   `onConflict: 'poll_id,user_id'`: This is the most important part. You are telling Supabase: "When I try to insert this row, if you find an *existing* row that has the same `poll_id` AND `user_id`, don't throw a unique constraint violation error. Instead, perform an UPDATE on that existing row with the data I've provided."

### Alternative: `ignoreDuplicates`

What if you want to insert a vote but *not* update it if it already exists? You can set `ignoreDuplicates` to `true`.

```typescript
export async function castInitialVote(voteData: Vote) {
  const cookieStore = cookies();
  const supabase = createServerClient(cookieStore);

  const { error } = await supabase
    .from('votes')
    .upsert(
      {
        poll_id: voteData.poll_id,
        user_id: voteData.user_id,
        option_id: voteData.option_id,
      },
      {
        onConflict: 'poll_id,user_id',
        // If a conflict occurs, do nothing. Don't update and don't error.
        ignoreDuplicates: true,
      }
    );

  if (error) {
    console.error('Error inserting initial vote:', error);
    throw new Error('Could not cast initial vote.');
  }

  console.log('Vote cast successfully (or was already present).');
}
```

This is useful for "first-time" actions where you don't want subsequent identical requests to change the original record.